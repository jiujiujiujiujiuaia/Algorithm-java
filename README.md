# Algorithm-java
- 使用java实现经典算法
- 探究jvm相关内容

## JVM
### 参数类型
参数类型有标准类型，非标准类型
- 标准类型就是一些类似于java -help, java -version,这里就不多数说了.
- 非标准类型一种是以-X开头,例如-Xint,-Xcomp等等
- 非标准类型另一种是以-XX开头
    - -XX:[+-][name],加号表示使用这个参数,减号表示不使用这个参数
    - -XX:[key]=[value],eg:-XX:MaxGcPauseMillis=500
    - Xms,Xmx这两个常见的其实可以写成 -XX:InitialHeapSize=?,-XX:MaxHeapSize=?
### bin目录下的工具
通过jdk自带的一些工具，我们可以做对jvm进程的初始参数以及参数值等等进行一个查看
- （查看运行的jvm及其唯一id）jps -l就可以查看当前服务器进程及其id
- (查看jvm运行时参数)jinfo -flag +参数名称 + id，就可以获得-XX参数的值或者使用过没有。例如jinfo -flag MaxHeapSize 11944
就可以获得最大堆内存的值

## 算法
### **动态规划**
- 累积类型
    - （一维度dp问题） 数塔，爬楼梯，偷房子等等，在一个约束条件下满足最大最小化问题（eg:某规则下最大值是多少）
    - （二维度dp问题） 背包等问题，在两个约束条件下满足最大最小化问题（eg:不超过容量的前提下最大的价值是多少）
- 次序类型 
    - LIS(最长子序列字串等等)
#### 背包问题
- **简单背包**
最普遍的做法是对于每一个物品，比较选择这个物品和前面物品价值总和不选择这个物品价值总和哪个更大
换句话说，每一步的状态，只和当前物品以及上一个物品有关->那么我们就可以把空间从[n个物品][质量w]的数组
优化成为[2][w]。
还可以利用一维数组进行进一步的优化，只有质量大于数组下标才进行比较大小，数组下标小于质量的话，则保持之前的结果
- **完全背包**
相比较前者，每一个物品不限量的拿取。最普遍的做法是不超过容量的前提下算出最多，能拿几个本次物品
，然后循环次数，只拿一个，拿两个，拿三个...这样比较看拿几个价值最大，间接的转换成了简单背包问题（相当于添加了重复的物品）
优化的策略非常巧妙，利用二进制的思想，不从拿一个遍历到拿n个，从1，2，4...左移一位的方式遍历，这样的话拿某个物品6次，原来需要遍历6次，现在只需要知道拿两次和拿四次的结果，只遍历了三次


