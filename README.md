# Algorithm-java
- 使用java实现经典算法
- 探究jvm相关内容

## JVM
### 参数类型
参数类型有标准类型，非标准类型
- 标准类型就是一些类似于java -help, java -version,这里就不多数说了.
- 非标准类型一种是以-X开头,例如-Xint,-Xcomp等等
- 非标准类型另一种是以-XX开头
    - -XX:[+-][name],加号表示使用这个参数,减号表示不使用这个参数
    - -XX:[key]=[value],eg:-XX:MaxGcPauseMillis=500
    - Xms,Xmx这两个常见的其实可以写成 -XX:InitialHeapSize=?,-XX:MaxHeapSize=?
### bin目录下的工具
通过jdk自带的一些工具，我们可以做对jvm进程的初始参数以及参数值等等进行一个查看
- （查看运行的jvm及其唯一id）jps -l就可以查看当前服务器进程及其id
- (查看jvm运行时参数)jinfo -flag +参数名称 + id，就可以获得-XX参数的值或者使用过没有。例如jinfo -flag MaxHeapSize 11944
就可以获得最大堆内存的值

## 算法
### **动态规划**
``
一开始对于动态规划的初印象就是，这个算法太神奇了把，竟然可以在有多种选择的情况下，找到最优的情况（比如数塔问题，怎么就可以不在暴力的情况下开天眼
找到正确的路线），后来就慢慢的有了思路，**首先**，记忆化的存储能够帮助你减少重复计算，**其次**，我一般都是自底向上的思考，把一个问题拆分
成小问题，然后直到初始状态，小问题是知道结果的，把小问题的结果保存下来，大问题就迎刃而解了，**最终**，也发现了一些问题
大多数情况下，dp问题好像用暴力去求解的情况是 2^n*数据大小，也就是说选或者不选这个物品，**并且**，有时候自顶向下更方便。
``
- 累积类型
    - （一维度dp问题） 数塔，爬楼梯，偷房子等等，在一个约束条件下满足最大最小化问题（eg:某规则下最大值是多少）
    - （二维度dp问题） 背包等问题，在两个约束条件下满足最大最小化问题（eg:不超过容量的前提下最大的价值是多少）
- 次序类型 
    - LIS(最长子序列字串等等)
#### 背包问题
- **简单背包**
最普遍的做法是对于每一个物品，比较选择这个物品和前面物品价值总和不选择这个物品价值总和哪个更大
换句话说，每一步的状态，只和当前物品以及上一个物品有关->那么我们就可以把空间从[n个物品][质量w]的数组
优化成为[2][w]。
还可以利用一维数组进行进一步的优化，只有质量大于数组下标才进行比较大小，数组下标小于质量的话，则保持之前的结果
- **完全背包**
相比较前者，每一个物品不限量的拿取。最普遍的做法是不超过容量的前提下算出最多，能拿几个本次物品
，然后循环次数，只拿一个，拿两个，拿三个...这样比较看拿几个价值最大，间接的转换成了简单背包问题（相当于添加了重复的物品）
优化的策略非常巧妙，利用二进制的思想，不从拿一个遍历到拿n个，从1，2，4...左移一位的方式遍历，这样的话拿某个物品6次，原来需要遍历6次，现在只需要知道拿两次和拿四次的结果，只遍历了三次


